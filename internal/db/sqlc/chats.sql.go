// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chats.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addChatParticipant = `-- name: AddChatParticipant :one

INSERT INTO chat_participants (chat_id, user_id, role)
VALUES ($1, $2, $3)
ON CONFLICT (chat_id, user_id) DO UPDATE SET role = EXCLUDED.role
RETURNING chat_id, user_id, role, joined_at
`

type AddChatParticipantParams struct {
	ChatID pgtype.UUID `json:"chat_id"`
	UserID pgtype.UUID `json:"user_id"`
	Role   string      `json:"role"`
}

// chat_participants
func (q *Queries) AddChatParticipant(ctx context.Context, arg AddChatParticipantParams) (ChatParticipant, error) {
	row := q.db.QueryRow(ctx, addChatParticipant, arg.ChatID, arg.UserID, arg.Role)
	var i ChatParticipant
	err := row.Scan(
		&i.ChatID,
		&i.UserID,
		&i.Role,
		&i.JoinedAt,
	)
	return i, err
}

const copyParticipantsToChat = `-- name: CopyParticipantsToChat :exec
INSERT INTO chat_participants (chat_id, user_id, role)
SELECT $2, cp.user_id, cp.role FROM chat_participants cp WHERE cp.chat_id = $1
ON CONFLICT (chat_id, user_id) DO NOTHING
`

type CopyParticipantsToChatParams struct {
	ChatID   pgtype.UUID `json:"chat_id"`
	ChatID_2 pgtype.UUID `json:"chat_id_2"`
}

func (q *Queries) CopyParticipantsToChat(ctx context.Context, arg CopyParticipantsToChatParams) error {
	_, err := q.db.Exec(ctx, copyParticipantsToChat, arg.ChatID, arg.ChatID_2)
	return err
}

const createChat = `-- name: CreateChat :one
INSERT INTO chats (bot_id, kind, parent_chat_id, title, created_by_user_id, metadata)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, bot_id, kind, parent_chat_id, title, created_by_user_id, metadata, enable_chat_memory, enable_private_memory, enable_public_memory, model_id, settings_metadata, created_at, updated_at
`

type CreateChatParams struct {
	BotID           pgtype.UUID `json:"bot_id"`
	Kind            string      `json:"kind"`
	ParentChatID    pgtype.UUID `json:"parent_chat_id"`
	Title           pgtype.Text `json:"title"`
	CreatedByUserID pgtype.UUID `json:"created_by_user_id"`
	Metadata        []byte      `json:"metadata"`
}

func (q *Queries) CreateChat(ctx context.Context, arg CreateChatParams) (Chat, error) {
	row := q.db.QueryRow(ctx, createChat,
		arg.BotID,
		arg.Kind,
		arg.ParentChatID,
		arg.Title,
		arg.CreatedByUserID,
		arg.Metadata,
	)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.BotID,
		&i.Kind,
		&i.ParentChatID,
		&i.Title,
		&i.CreatedByUserID,
		&i.Metadata,
		&i.EnableChatMemory,
		&i.EnablePrivateMemory,
		&i.EnablePublicMemory,
		&i.ModelID,
		&i.SettingsMetadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createChatMessage = `-- name: CreateChatMessage :one

INSERT INTO chat_messages (chat_id, bot_id, route_id, sender_channel_identity_id, sender_user_id, platform, external_message_id, role, content, metadata)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, chat_id, bot_id, route_id, sender_channel_identity_id, sender_user_id, platform, external_message_id, role, content, metadata, created_at
`

type CreateChatMessageParams struct {
	ChatID                  pgtype.UUID `json:"chat_id"`
	BotID                   pgtype.UUID `json:"bot_id"`
	RouteID                 pgtype.UUID `json:"route_id"`
	SenderChannelIdentityID pgtype.UUID `json:"sender_channel_identity_id"`
	SenderUserID            pgtype.UUID `json:"sender_user_id"`
	Platform                pgtype.Text `json:"platform"`
	ExternalMessageID       pgtype.Text `json:"external_message_id"`
	Role                    string      `json:"role"`
	Content                 []byte      `json:"content"`
	Metadata                []byte      `json:"metadata"`
}

// chat_messages
func (q *Queries) CreateChatMessage(ctx context.Context, arg CreateChatMessageParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, createChatMessage,
		arg.ChatID,
		arg.BotID,
		arg.RouteID,
		arg.SenderChannelIdentityID,
		arg.SenderUserID,
		arg.Platform,
		arg.ExternalMessageID,
		arg.Role,
		arg.Content,
		arg.Metadata,
	)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.BotID,
		&i.RouteID,
		&i.SenderChannelIdentityID,
		&i.SenderUserID,
		&i.Platform,
		&i.ExternalMessageID,
		&i.Role,
		&i.Content,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const createChatRoute = `-- name: CreateChatRoute :one

INSERT INTO chat_routes (chat_id, bot_id, platform, channel_config_id, conversation_id, thread_id, reply_target, metadata)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, chat_id, bot_id, platform, channel_config_id, conversation_id, thread_id, reply_target, metadata, created_at, updated_at
`

type CreateChatRouteParams struct {
	ChatID          pgtype.UUID `json:"chat_id"`
	BotID           pgtype.UUID `json:"bot_id"`
	Platform        string      `json:"platform"`
	ChannelConfigID pgtype.UUID `json:"channel_config_id"`
	ConversationID  string      `json:"conversation_id"`
	ThreadID        pgtype.Text `json:"thread_id"`
	ReplyTarget     pgtype.Text `json:"reply_target"`
	Metadata        []byte      `json:"metadata"`
}

// chat_routes
func (q *Queries) CreateChatRoute(ctx context.Context, arg CreateChatRouteParams) (ChatRoute, error) {
	row := q.db.QueryRow(ctx, createChatRoute,
		arg.ChatID,
		arg.BotID,
		arg.Platform,
		arg.ChannelConfigID,
		arg.ConversationID,
		arg.ThreadID,
		arg.ReplyTarget,
		arg.Metadata,
	)
	var i ChatRoute
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.BotID,
		&i.Platform,
		&i.ChannelConfigID,
		&i.ConversationID,
		&i.ThreadID,
		&i.ReplyTarget,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteChat = `-- name: DeleteChat :exec
DELETE FROM chats WHERE id = $1
`

func (q *Queries) DeleteChat(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteChat, id)
	return err
}

const deleteChatMessagesByChat = `-- name: DeleteChatMessagesByChat :exec
DELETE FROM chat_messages WHERE chat_id = $1
`

func (q *Queries) DeleteChatMessagesByChat(ctx context.Context, chatID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteChatMessagesByChat, chatID)
	return err
}

const deleteChatRoute = `-- name: DeleteChatRoute :exec
DELETE FROM chat_routes WHERE id = $1
`

func (q *Queries) DeleteChatRoute(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteChatRoute, id)
	return err
}

const findChatRoute = `-- name: FindChatRoute :one
SELECT id, chat_id, bot_id, platform, channel_config_id, conversation_id, thread_id, reply_target, metadata, created_at, updated_at
FROM chat_routes
WHERE bot_id = $1 AND platform = $2 AND conversation_id = $3
  AND COALESCE(thread_id, '') = COALESCE($4, '')
LIMIT 1
`

type FindChatRouteParams struct {
	BotID          pgtype.UUID `json:"bot_id"`
	Platform       string      `json:"platform"`
	ConversationID string      `json:"conversation_id"`
	ThreadID       pgtype.Text `json:"thread_id"`
}

func (q *Queries) FindChatRoute(ctx context.Context, arg FindChatRouteParams) (ChatRoute, error) {
	row := q.db.QueryRow(ctx, findChatRoute,
		arg.BotID,
		arg.Platform,
		arg.ConversationID,
		arg.ThreadID,
	)
	var i ChatRoute
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.BotID,
		&i.Platform,
		&i.ChannelConfigID,
		&i.ConversationID,
		&i.ThreadID,
		&i.ReplyTarget,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChatByID = `-- name: GetChatByID :one
SELECT id, bot_id, kind, parent_chat_id, title, created_by_user_id, metadata, enable_chat_memory, enable_private_memory, enable_public_memory, model_id, settings_metadata, created_at, updated_at
FROM chats
WHERE id = $1
`

func (q *Queries) GetChatByID(ctx context.Context, id pgtype.UUID) (Chat, error) {
	row := q.db.QueryRow(ctx, getChatByID, id)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.BotID,
		&i.Kind,
		&i.ParentChatID,
		&i.Title,
		&i.CreatedByUserID,
		&i.Metadata,
		&i.EnableChatMemory,
		&i.EnablePrivateMemory,
		&i.EnablePublicMemory,
		&i.ModelID,
		&i.SettingsMetadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChatParticipant = `-- name: GetChatParticipant :one
SELECT chat_id, user_id, role, joined_at
FROM chat_participants
WHERE chat_id = $1 AND user_id = $2
`

type GetChatParticipantParams struct {
	ChatID pgtype.UUID `json:"chat_id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetChatParticipant(ctx context.Context, arg GetChatParticipantParams) (ChatParticipant, error) {
	row := q.db.QueryRow(ctx, getChatParticipant, arg.ChatID, arg.UserID)
	var i ChatParticipant
	err := row.Scan(
		&i.ChatID,
		&i.UserID,
		&i.Role,
		&i.JoinedAt,
	)
	return i, err
}

const getChatReadAccessByUser = `-- name: GetChatReadAccessByUser :one
WITH participant_access AS (
  SELECT 'participant'::text AS access_mode,
         cp.role AS participant_role,
         NULL::timestamptz AS last_observed_at
  FROM chat_participants cp
  WHERE cp.chat_id = $1 AND cp.user_id = $2
),
observed_access AS (
  SELECT 'channel_identity_observed'::text AS access_mode,
         ''::text AS participant_role,
         MAX(cap.last_seen_at) AS last_observed_at
  FROM chat_channel_identity_presence cap
  JOIN channel_identities ci ON ci.id = cap.channel_identity_id
  WHERE cap.chat_id = $1 AND ci.user_id = $2
  GROUP BY cap.chat_id
),
all_access AS (
  SELECT access_mode, participant_role, last_observed_at FROM participant_access
  UNION ALL
  SELECT access_mode, participant_role, last_observed_at FROM observed_access
)
SELECT access_mode, participant_role, last_observed_at
FROM all_access
ORDER BY CASE WHEN access_mode = 'participant' THEN 0 ELSE 1 END, last_observed_at DESC NULLS LAST
LIMIT 1
`

type GetChatReadAccessByUserParams struct {
	ChatID pgtype.UUID `json:"chat_id"`
	UserID pgtype.UUID `json:"user_id"`
}

type GetChatReadAccessByUserRow struct {
	AccessMode      string             `json:"access_mode"`
	ParticipantRole string             `json:"participant_role"`
	LastObservedAt  pgtype.Timestamptz `json:"last_observed_at"`
}

func (q *Queries) GetChatReadAccessByUser(ctx context.Context, arg GetChatReadAccessByUserParams) (GetChatReadAccessByUserRow, error) {
	row := q.db.QueryRow(ctx, getChatReadAccessByUser, arg.ChatID, arg.UserID)
	var i GetChatReadAccessByUserRow
	err := row.Scan(&i.AccessMode, &i.ParticipantRole, &i.LastObservedAt)
	return i, err
}

const getChatRouteByID = `-- name: GetChatRouteByID :one
SELECT id, chat_id, bot_id, platform, channel_config_id, conversation_id, thread_id, reply_target, metadata, created_at, updated_at
FROM chat_routes
WHERE id = $1
`

func (q *Queries) GetChatRouteByID(ctx context.Context, id pgtype.UUID) (ChatRoute, error) {
	row := q.db.QueryRow(ctx, getChatRouteByID, id)
	var i ChatRoute
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.BotID,
		&i.Platform,
		&i.ChannelConfigID,
		&i.ConversationID,
		&i.ThreadID,
		&i.ReplyTarget,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChatSettings = `-- name: GetChatSettings :one
SELECT id AS chat_id, enable_chat_memory, enable_private_memory, enable_public_memory, model_id, settings_metadata AS metadata, updated_at
FROM chats
WHERE id = $1
`

type GetChatSettingsRow struct {
	ChatID              pgtype.UUID        `json:"chat_id"`
	EnableChatMemory    bool               `json:"enable_chat_memory"`
	EnablePrivateMemory bool               `json:"enable_private_memory"`
	EnablePublicMemory  bool               `json:"enable_public_memory"`
	ModelID             pgtype.Text        `json:"model_id"`
	Metadata            []byte             `json:"metadata"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetChatSettings(ctx context.Context, id pgtype.UUID) (GetChatSettingsRow, error) {
	row := q.db.QueryRow(ctx, getChatSettings, id)
	var i GetChatSettingsRow
	err := row.Scan(
		&i.ChatID,
		&i.EnableChatMemory,
		&i.EnablePrivateMemory,
		&i.EnablePublicMemory,
		&i.ModelID,
		&i.Metadata,
		&i.UpdatedAt,
	)
	return i, err
}

const listChatMessages = `-- name: ListChatMessages :many
SELECT id, chat_id, bot_id, route_id, sender_channel_identity_id, sender_user_id, platform, external_message_id, role, content, metadata, created_at
FROM chat_messages
WHERE chat_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListChatMessages(ctx context.Context, chatID pgtype.UUID) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, listChatMessages, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.BotID,
			&i.RouteID,
			&i.SenderChannelIdentityID,
			&i.SenderUserID,
			&i.Platform,
			&i.ExternalMessageID,
			&i.Role,
			&i.Content,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChatMessagesBefore = `-- name: ListChatMessagesBefore :many
SELECT id, chat_id, bot_id, route_id, sender_channel_identity_id, sender_user_id, platform, external_message_id, role, content, metadata, created_at
FROM chat_messages
WHERE chat_id = $1 AND created_at < $2
ORDER BY created_at DESC
LIMIT $3
`

type ListChatMessagesBeforeParams struct {
	ChatID    pgtype.UUID        `json:"chat_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	Limit     int32              `json:"limit"`
}

func (q *Queries) ListChatMessagesBefore(ctx context.Context, arg ListChatMessagesBeforeParams) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, listChatMessagesBefore, arg.ChatID, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.BotID,
			&i.RouteID,
			&i.SenderChannelIdentityID,
			&i.SenderUserID,
			&i.Platform,
			&i.ExternalMessageID,
			&i.Role,
			&i.Content,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChatMessagesLatest = `-- name: ListChatMessagesLatest :many
SELECT id, chat_id, bot_id, route_id, sender_channel_identity_id, sender_user_id, platform, external_message_id, role, content, metadata, created_at
FROM chat_messages
WHERE chat_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type ListChatMessagesLatestParams struct {
	ChatID pgtype.UUID `json:"chat_id"`
	Limit  int32       `json:"limit"`
}

func (q *Queries) ListChatMessagesLatest(ctx context.Context, arg ListChatMessagesLatestParams) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, listChatMessagesLatest, arg.ChatID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.BotID,
			&i.RouteID,
			&i.SenderChannelIdentityID,
			&i.SenderUserID,
			&i.Platform,
			&i.ExternalMessageID,
			&i.Role,
			&i.Content,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChatMessagesSince = `-- name: ListChatMessagesSince :many
SELECT id, chat_id, bot_id, route_id, sender_channel_identity_id, sender_user_id, platform, external_message_id, role, content, metadata, created_at
FROM chat_messages
WHERE chat_id = $1 AND created_at >= $2
ORDER BY created_at ASC
`

type ListChatMessagesSinceParams struct {
	ChatID    pgtype.UUID        `json:"chat_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListChatMessagesSince(ctx context.Context, arg ListChatMessagesSinceParams) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, listChatMessagesSince, arg.ChatID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.BotID,
			&i.RouteID,
			&i.SenderChannelIdentityID,
			&i.SenderUserID,
			&i.Platform,
			&i.ExternalMessageID,
			&i.Role,
			&i.Content,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChatParticipants = `-- name: ListChatParticipants :many
SELECT chat_id, user_id, role, joined_at
FROM chat_participants
WHERE chat_id = $1
ORDER BY joined_at ASC
`

func (q *Queries) ListChatParticipants(ctx context.Context, chatID pgtype.UUID) ([]ChatParticipant, error) {
	rows, err := q.db.Query(ctx, listChatParticipants, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatParticipant
	for rows.Next() {
		var i ChatParticipant
		if err := rows.Scan(
			&i.ChatID,
			&i.UserID,
			&i.Role,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChatRoutes = `-- name: ListChatRoutes :many
SELECT id, chat_id, bot_id, platform, channel_config_id, conversation_id, thread_id, reply_target, metadata, created_at, updated_at
FROM chat_routes
WHERE chat_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListChatRoutes(ctx context.Context, chatID pgtype.UUID) ([]ChatRoute, error) {
	rows, err := q.db.Query(ctx, listChatRoutes, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatRoute
	for rows.Next() {
		var i ChatRoute
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.BotID,
			&i.Platform,
			&i.ChannelConfigID,
			&i.ConversationID,
			&i.ThreadID,
			&i.ReplyTarget,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChatsByBotAndUser = `-- name: ListChatsByBotAndUser :many
SELECT c.id, c.bot_id, c.kind, c.parent_chat_id, c.title, c.created_by_user_id, c.metadata, c.enable_chat_memory, c.enable_private_memory, c.enable_public_memory, c.model_id, c.settings_metadata, c.created_at, c.updated_at
FROM chats c
JOIN chat_participants cp ON cp.chat_id = c.id
WHERE c.bot_id = $1 AND cp.user_id = $2
ORDER BY c.updated_at DESC
`

type ListChatsByBotAndUserParams struct {
	BotID  pgtype.UUID `json:"bot_id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) ListChatsByBotAndUser(ctx context.Context, arg ListChatsByBotAndUserParams) ([]Chat, error) {
	rows, err := q.db.Query(ctx, listChatsByBotAndUser, arg.BotID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chat
	for rows.Next() {
		var i Chat
		if err := rows.Scan(
			&i.ID,
			&i.BotID,
			&i.Kind,
			&i.ParentChatID,
			&i.Title,
			&i.CreatedByUserID,
			&i.Metadata,
			&i.EnableChatMemory,
			&i.EnablePrivateMemory,
			&i.EnablePublicMemory,
			&i.ModelID,
			&i.SettingsMetadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listThreadsByParent = `-- name: ListThreadsByParent :many
SELECT id, bot_id, kind, parent_chat_id, title, created_by_user_id, metadata, enable_chat_memory, enable_private_memory, enable_public_memory, model_id, settings_metadata, created_at, updated_at
FROM chats
WHERE parent_chat_id = $1 AND kind = 'thread'
ORDER BY created_at DESC
`

func (q *Queries) ListThreadsByParent(ctx context.Context, parentChatID pgtype.UUID) ([]Chat, error) {
	rows, err := q.db.Query(ctx, listThreadsByParent, parentChatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chat
	for rows.Next() {
		var i Chat
		if err := rows.Scan(
			&i.ID,
			&i.BotID,
			&i.Kind,
			&i.ParentChatID,
			&i.Title,
			&i.CreatedByUserID,
			&i.Metadata,
			&i.EnableChatMemory,
			&i.EnablePrivateMemory,
			&i.EnablePublicMemory,
			&i.ModelID,
			&i.SettingsMetadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVisibleChatsByBotAndUser = `-- name: ListVisibleChatsByBotAndUser :many
WITH participant_chats AS (
  SELECT c.id, c.bot_id, c.kind, c.parent_chat_id, c.title, c.created_by_user_id, c.metadata, c.created_at, c.updated_at,
         'participant'::text AS access_mode,
         cp.role AS participant_role,
         NULL::timestamptz AS last_observed_at
  FROM chats c
  JOIN chat_participants cp ON cp.chat_id = c.id
  WHERE c.bot_id = $1 AND cp.user_id = $2
),
observed_chats AS (
  SELECT c.id, c.bot_id, c.kind, c.parent_chat_id, c.title, c.created_by_user_id, c.metadata, c.created_at, c.updated_at,
         'channel_identity_observed'::text AS access_mode,
         ''::text AS participant_role,
         MAX(cap.last_seen_at) AS last_observed_at
  FROM chats c
  JOIN chat_channel_identity_presence cap ON cap.chat_id = c.id
  JOIN channel_identities ci ON ci.id = cap.channel_identity_id
  WHERE c.bot_id = $1
    AND ci.user_id = $2
    AND NOT EXISTS (
      SELECT 1 FROM chat_participants cp
      WHERE cp.chat_id = c.id AND cp.user_id = $2
    )
  GROUP BY c.id, c.bot_id, c.kind, c.parent_chat_id, c.title, c.created_by_user_id, c.metadata, c.created_at, c.updated_at
)
SELECT id, bot_id, kind, parent_chat_id, title, created_by_user_id, metadata, created_at, updated_at,
       access_mode, participant_role, last_observed_at
FROM (
  SELECT id, bot_id, kind, parent_chat_id, title, created_by_user_id, metadata, created_at, updated_at, access_mode, participant_role, last_observed_at FROM participant_chats
  UNION ALL
  SELECT id, bot_id, kind, parent_chat_id, title, created_by_user_id, metadata, created_at, updated_at, access_mode, participant_role, last_observed_at FROM observed_chats
) v
ORDER BY v.updated_at DESC, v.last_observed_at DESC NULLS LAST
`

type ListVisibleChatsByBotAndUserParams struct {
	BotID  pgtype.UUID `json:"bot_id"`
	UserID pgtype.UUID `json:"user_id"`
}

type ListVisibleChatsByBotAndUserRow struct {
	ID              pgtype.UUID        `json:"id"`
	BotID           pgtype.UUID        `json:"bot_id"`
	Kind            string             `json:"kind"`
	ParentChatID    pgtype.UUID        `json:"parent_chat_id"`
	Title           pgtype.Text        `json:"title"`
	CreatedByUserID pgtype.UUID        `json:"created_by_user_id"`
	Metadata        []byte             `json:"metadata"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	AccessMode      string             `json:"access_mode"`
	ParticipantRole string             `json:"participant_role"`
	LastObservedAt  pgtype.Timestamptz `json:"last_observed_at"`
}

func (q *Queries) ListVisibleChatsByBotAndUser(ctx context.Context, arg ListVisibleChatsByBotAndUserParams) ([]ListVisibleChatsByBotAndUserRow, error) {
	rows, err := q.db.Query(ctx, listVisibleChatsByBotAndUser, arg.BotID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListVisibleChatsByBotAndUserRow
	for rows.Next() {
		var i ListVisibleChatsByBotAndUserRow
		if err := rows.Scan(
			&i.ID,
			&i.BotID,
			&i.Kind,
			&i.ParentChatID,
			&i.Title,
			&i.CreatedByUserID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccessMode,
			&i.ParticipantRole,
			&i.LastObservedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeChatParticipant = `-- name: RemoveChatParticipant :exec
DELETE FROM chat_participants WHERE chat_id = $1 AND user_id = $2
`

type RemoveChatParticipantParams struct {
	ChatID pgtype.UUID `json:"chat_id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) RemoveChatParticipant(ctx context.Context, arg RemoveChatParticipantParams) error {
	_, err := q.db.Exec(ctx, removeChatParticipant, arg.ChatID, arg.UserID)
	return err
}

const touchChat = `-- name: TouchChat :exec
UPDATE chats SET updated_at = now() WHERE id = $1
`

func (q *Queries) TouchChat(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, touchChat, id)
	return err
}

const updateChatRouteReplyTarget = `-- name: UpdateChatRouteReplyTarget :exec
UPDATE chat_routes SET reply_target = $2, updated_at = now() WHERE id = $1
`

type UpdateChatRouteReplyTargetParams struct {
	ID          pgtype.UUID `json:"id"`
	ReplyTarget pgtype.Text `json:"reply_target"`
}

func (q *Queries) UpdateChatRouteReplyTarget(ctx context.Context, arg UpdateChatRouteReplyTargetParams) error {
	_, err := q.db.Exec(ctx, updateChatRouteReplyTarget, arg.ID, arg.ReplyTarget)
	return err
}

const updateChatTitle = `-- name: UpdateChatTitle :one
UPDATE chats SET title = $2, updated_at = now()
WHERE id = $1
RETURNING id, bot_id, kind, parent_chat_id, title, created_by_user_id, metadata, enable_chat_memory, enable_private_memory, enable_public_memory, model_id, settings_metadata, created_at, updated_at
`

type UpdateChatTitleParams struct {
	ID    pgtype.UUID `json:"id"`
	Title pgtype.Text `json:"title"`
}

func (q *Queries) UpdateChatTitle(ctx context.Context, arg UpdateChatTitleParams) (Chat, error) {
	row := q.db.QueryRow(ctx, updateChatTitle, arg.ID, arg.Title)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.BotID,
		&i.Kind,
		&i.ParentChatID,
		&i.Title,
		&i.CreatedByUserID,
		&i.Metadata,
		&i.EnableChatMemory,
		&i.EnablePrivateMemory,
		&i.EnablePublicMemory,
		&i.ModelID,
		&i.SettingsMetadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertChatChannelIdentityPresence = `-- name: UpsertChatChannelIdentityPresence :exec
INSERT INTO chat_channel_identity_presence (chat_id, channel_identity_id, first_seen_at, last_seen_at, message_count)
VALUES ($1, $2, now(), now(), 1)
ON CONFLICT (chat_id, channel_identity_id)
DO UPDATE SET
  last_seen_at = now(),
  message_count = chat_channel_identity_presence.message_count + 1
`

type UpsertChatChannelIdentityPresenceParams struct {
	ChatID            pgtype.UUID `json:"chat_id"`
	ChannelIdentityID pgtype.UUID `json:"channel_identity_id"`
}

func (q *Queries) UpsertChatChannelIdentityPresence(ctx context.Context, arg UpsertChatChannelIdentityPresenceParams) error {
	_, err := q.db.Exec(ctx, upsertChatChannelIdentityPresence, arg.ChatID, arg.ChannelIdentityID)
	return err
}

const upsertChatSettings = `-- name: UpsertChatSettings :one

UPDATE chats
SET enable_chat_memory = $2,
    enable_private_memory = $3,
    enable_public_memory = $4,
    model_id = $5,
    settings_metadata = $6
WHERE id = $1
RETURNING id AS chat_id, enable_chat_memory, enable_private_memory, enable_public_memory, model_id, settings_metadata AS metadata, updated_at
`

type UpsertChatSettingsParams struct {
	ID                  pgtype.UUID `json:"id"`
	EnableChatMemory    bool        `json:"enable_chat_memory"`
	EnablePrivateMemory bool        `json:"enable_private_memory"`
	EnablePublicMemory  bool        `json:"enable_public_memory"`
	ModelID             pgtype.Text `json:"model_id"`
	SettingsMetadata    []byte      `json:"settings_metadata"`
}

type UpsertChatSettingsRow struct {
	ChatID              pgtype.UUID        `json:"chat_id"`
	EnableChatMemory    bool               `json:"enable_chat_memory"`
	EnablePrivateMemory bool               `json:"enable_private_memory"`
	EnablePublicMemory  bool               `json:"enable_public_memory"`
	ModelID             pgtype.Text        `json:"model_id"`
	Metadata            []byte             `json:"metadata"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
}

// chat_settings
func (q *Queries) UpsertChatSettings(ctx context.Context, arg UpsertChatSettingsParams) (UpsertChatSettingsRow, error) {
	row := q.db.QueryRow(ctx, upsertChatSettings,
		arg.ID,
		arg.EnableChatMemory,
		arg.EnablePrivateMemory,
		arg.EnablePublicMemory,
		arg.ModelID,
		arg.SettingsMetadata,
	)
	var i UpsertChatSettingsRow
	err := row.Scan(
		&i.ChatID,
		&i.EnableChatMemory,
		&i.EnablePrivateMemory,
		&i.EnablePublicMemory,
		&i.ModelID,
		&i.Metadata,
		&i.UpdatedAt,
	)
	return i, err
}
